% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flash.R
\name{flash_add_greedy}
\alias{flash_add_greedy}
\title{Fit Empirical Bayes Matrix Factorization (greedy algorithm)}
\usage{
flash_add_greedy(data, Kmax = 1, f_init = NULL, var_type = c("by_column",
  "by_row", "constant", "zero", "kroneker"), init_fn = "udv_si", tol = 0.01,
  ebnm_fn = ebnm_pn, ebnm_param = flash_default_ebnm_param(ebnm_fn),
  gl = NULL, fixgl = FALSE, gf = NULL, fixgf = FALSE, verbose = FALSE,
  nullcheck = TRUE, seed = 123)
}
\arguments{
\item{data}{An n by p matrix or a flash data object created using
\code{flash_set_data}.}

\item{Kmax}{The maximum number of factors to be added to the flash
object. (If \code{nullcheck = TRUE}, the actual number of factors
added might be less than \code{Kmax}.)}

\item{f_init}{The flash object to which new factors are to be added.
If \code{f_init = NULL}, then a new flash fit object is created.}

\item{var_type}{The type of variance structure to assume for
residuals.}

\item{init_fn}{The function used to initialize factors. This
function should take parameters (Y,K) where Y is an n by p matrix
of data (or a flash data object) and K is a number of factors.  It
should output a list with elements (u,d,v) where u is n by K matrix
v is a p by K matrix and d is a K vector. See \code{udv_si} for an
example.  (If the input data includes missing values then this
function must be able to deal with missing values in its input
matrix.)}

\item{tol}{Specifies how much the objective can change in a single
iteration to be considered not converged.}

\item{ebnm_fn}{The function used to solve the Empirical Bayes Normal
Means problem.}

\item{ebnm_param}{A named list containing parameters to be passed to
ebnm_fn when optimizing; defaults are set by
\code{flash_default_ebnm_param()}.}

\item{gl}{Passed into \code{ebnm_fn} as parameter \code{g} (used to
fix or initialize priors on the loadings). This can be a single
prior or a list of length \code{Kmax}, with \code{gl[[k]]}
specifying the prior for the kth loading.}

\item{fixgl}{Passed into \code{ebnm_fn} as parameter \code{fixg} (used
to fix priors on the loadings). This can be a single boolean which
specifies \code{fixg} for all loadings or a vector of booleans,
with \code{fixg}[k] specifying \code{fixg} for the kth loading.}

\item{verbose}{If TRUE, various progress updates will be printed.}

\item{nullcheck}{If TRUE, then after running hill-climbing updates,
\code{flash} will check whether the achieved optimum is better than
setting the factor to 0. If the check is performed and fails then
the factor will be set to 0 in the returned fit.}

\item{seed}{A random number seed to use before running \code{flash}
- for reproducibility. Set to NULL if you don't want the seed set.
(The seed can affect initialization when there are missing data;
otherwise the algorithm is deterministic.)}

\item{gl}{Passed into \code{ebnm_fn} as parameter \code{g} (used to
fix or initialize priors on the factors). This can be a single
prior or a list of length \code{Kmax}, with \code{gf[[k]]}
specifying the prior for the kth factor.}

\item{fixgl}{Passed into \code{ebnm_fn} as parameter \code{fixg} (used
to fix priors on the factors). This can be a single boolean which
specifies \code{fixg} for all factors or a vector of booleans,
with \code{fixg}[k] specifying \code{fixg} for the kth factor.}
}
\value{
A fitted flash object.
}
\description{
This implements the greedy algorithm from Wang and
  Stephens.  It can be used to add factors to an existing fit, or
  start from scratch.  It adds factors iteratively, at each stage
  adding a new factor and then optimizing it.  It is "greedy" in that
  it does not return to re-optimize previous factors.  The function
  stops when an added factor contributes nothing or when \code{Kmax}
  is reached. Each new factor is intialized by applying the function
  \code{init_fn} to the residuals after removing previously-fitted
  factors.
}
\examples{
l = rnorm(100)
f = rnorm(10)
Y = outer(l,f) + matrix(rnorm(1000),nrow=100)
f = flash_add_greedy(Y,10)

# Gives the weights for each factor (analogue of singular values).
flash_get_ldf(f)$d

# Example to show how to use a different initialization function.
library(softImpute)
f2 = flash_add_greedy(Y,10,init_fn = function(x,K=1){
  softImpute(x,K,lambda=10)
})

}
